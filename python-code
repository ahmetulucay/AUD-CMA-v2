# Ahmet Ulucay Drag-and-Carry Multiplication Algorithm v2 (AUD-CMA-v2)

# This version:

# - Works for any input size thanks to Pythonâ€™s int
# - Ensures the last sliding window is not skipped
# - Ensures Convolutional Form with right-to-left carry propagation
# - Preserves the leftmost digit in full
# - Uses a clean loop range:
#     i in [k-1, len(padded)-(k-1)]

def audcma_v2(n_str, b_str):
    n = [int(d) for d in n_str]
    b = [int(d) for d in b_str]

    k = len(b)
    base_digit = b[0]

    # Step 1: Multiply each digit of n by base_digit
    result = [digit * base_digit for digit in n]

    # Step 2: Pad with (k - 1) zeros on both sides
    padded = [0] * (k - 1) + result + [0] * (k - 1)

    # Step 3: Sliding window sum and carry from right to left
    output = []
    carry = 0
    for i in range(len(padded) - 1, -1, -1):
        window = padded[max(0, i - k + 1):i + 1]
        window_sum = sum(window) + carry

        if k - 1 <= i <= len(padded) - (k - 1):
            output.append(window_sum % 10)
            carry = window_sum // 10
        elif i == k - 2:
            output.append(window_sum)  # leftmost full value

    output.reverse()
    return int(''.join(map(str, output)))
